<p>
  I've written a lot of code at this point, and the main place I find myself in programming is trying to figure out why my program doesn't do what I'm trying to get it to do. 
</p>

<p>
  If you're not constantly in this state then you're probably not pushing your programs as far as they could be going. In programming while its true that simplicity is key, no regular person interacts with a program until its complexity has hit a certain point, then a human may choose to interact with the system for extended periods of time and find it enjoyable.
</p>

<p>
  Anyways, putting that aside. You a creator of systems is making a complex system and sometimes you find yourself just shellshocked staring at your computer screen, trying to make it do what you need it to do, whenever this starts happening, it means that the cognitive overhead of building in your system is just way too high.
</p>

<p>
  Once I read an article online or a blog post where they had mentioned that a programmer is a person who is paid to hold a complex system in their head and know it so well that they're able to change it in any way and refactor it in their mind before they even touch the keyboard. While I agree that this is true, I don't think the complex system that is in your head has to contain all the details or even be that complex, it's simply because we literally cannot hold that much information and operate on it quickly in our brain to a certain extent, thus you do have to spend time abstracting.
</p>

<p>
  Ok, I'll stop making tangents. You are a person who is making a complex system and you're shellshocked at your computer, you can't do anything because you don't know what you need to do to make it happen, perhaps you're trying to do the changes in your mind, but it clashes with something else and now you're thinking about something else. Well you need to modularize and organize, because the only way to get more complex is to make things less complex, the fact is there are things that you completely understand, and they are usually small non-complex things, the goal is to turn your complex system into layers of small non-complex system which you fully understand ad-infimum. 
</p>

<p>
  Following the above, you can abstract to a new cognitive level and drop down to different cognitive levels when you need to debug things, for each of your small easy to understand pieces you assume they work perfectly when you're problem solving and if your final complex system has a problem, it's because of two things, one of your small subsystems has the problem, and in that case since you know exactly how that system should behave you can figure that out fast, or it's a problem in the way those subsystems are combined, and in that case it's also not too hard to debug since you only combined a few subsystems together.
</p>

<p>
  If you follow these guidelines I swear you can make a computer do anything you want (you know what I mean).
</p>


<h2>why are complex systems good? (aside)</h2>

<p>
  This is precisely the reason why there is no profession tick tack toe league but there is for chess and multiple games, there is simply not enough possible ways to express yourself in tick tack toe, whereas in chess or in other games there are enough states that can be achieved to express yourself, enough to make the experience enjoyable.
</p>

<p>
  What we've learned here is that humans interact with systems as long as there is depth to them, where depth is the number of states acheivable by the system, also note humans can also cull out useless data channels, so even if you're playing a game that has tons of potential configurations, the human mind will batch together all configurations which are pretty much the same experience.
</p>

<p>
  Additionally something attracting to humans are systems which are relatable, if you code up minesweeper one with graphics of real land mines that explode when you touch them and one whith a black and white interface such as the original version on windows XP then most people will find the 3D explosion version more "fun" (yes there are exceptions if you're someone who is trying to speedrun etc...) but to a certain extend raw systems with no relating component detracts from the human experience. At an extreme the difference would be viewing the game state in binary vs viewing it on a screen, clearly one is better.
</p>
