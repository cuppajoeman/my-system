<p>
    Git submodules provide a way to consider any repository as a versioned "package" that can be included in any other git repo.
</p>

<h1>clone a repo that has submodules</h1>

<pre>
    <code>
        git clone --recurse-submodules -j8 git://github.com/foo/bar.git
    </code>
</pre>

<p>
    Note: -j8 is an optional performance optimization that became available in version 2.8, and fetches up to 8 submodules at a time in parallel â€” see man git-clone
</p>

<h1>clone in repositories after cloning a repo</h1>

<p>
    When you clone a repository git will <b>not</b> automatically clone in the contents of any submodules, but it will clone an empty directory with the name of that repository, in order to actually get the contents of those submodules you have to do the following
</p>

<pre>
    <code>
        git submodule init
        git submodule update
    </code>
</pre>

<h1>mistakes</h1>

<h2>HEAD detached from 54b9bf8</h2>

<p>
    If you see that you are on a detached head, this means that you cannot commit any changes here, if you have uncommitted changes you can switch to main with <code>git checkout main</code>, if you do have committed changes then you have to do this:
</p>
<pre>
    <code>
git switch -c temp-work
git switch main
git merge temp-work
git branch -d temp-work
    </code>
</pre>

<p>
    To avoid this problem in the future, we have to realize why this usually occurs, it happens when you clone a repository and initialize its submodules such as by doing <code>git clone --recursive URL</code>, it makes sense that git puts every submodule at its respective commit, this is so that you can have reproducible behavior when you clone in submodules, but sometimes you know what you want the most up-to-date version of a submodule, in that case run this after the fact:
</p>

<pre>
    <code>
        git submodule foreach --recursive git checkout main
    </code>
</pre>
